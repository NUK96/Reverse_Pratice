# 第七天

## 一、函数递归

1. 递归，其实就是寻找规律，解决重复复杂的事情
2. 使用递归的时候，一定要给予递归结束的条件
3. 递归的结果是`逆序`相加
4. 案例：
	- 利用递归将十进制转换成二进制

```c
//利用递归的倒序输出，将十进制转化成二进制
//

#include <stdio.h>
#include <stdlib.h>

int Dec2Bin(unsigned n)
{
	if (n == 0)
	{
		return;
	}
	Dec2Bin(n / 2);
	printf("%d",n%2);
}

int main()
{
	Dec2Bin(125);

	return 0;
}
```

## 二、数组

1. 定义数组
	- int poke[14];	//在内存中连续定义14个变量
2. 初始化数据
	- int poke[14] = {2,3,4,5,6,7,8,9,10,J,Q,K,A};
	- 没有初始化值，默认为0；
	- int poke[] = {2,3,4,5,6,7,8,9,10,J,Q,K,A};     //根据初始值的数量决定数组的大小
	- int poke[13] = {0}         //表示13个变量的值都为0
3. 访问数组，数组的下标
	- poke[i]
4. 数组的注意事项：

  - 参数在传入函数中，实参和形参要对应；
  - 数组作为参数传入函数中，其实`传的是地址`



## 三、排序算法

### 1、冒泡排序

1. 冒泡排序就是将相邻的两个数进行比大小，前者比后者大，则两个位置的数进行交换，一轮下来最大的数会被排到最后面（这种是大的往后排，小的往前排的话就恰恰相反）

  ```c
/*
* 初始值：3 2 5 1 4
* 
* 第一轮排序
* 2 3 5 1 4	//2和3进行比较，大的往后排
* 2 3 5 1 4	//3和5进行比较，3比5小，原地不动
* 2 3 1 5 4	//1和5进行比较，大的往后排
* 2 3 1 4 5	//5和4进行比较，大的往后排
* 
* 第二轮（继上一轮继续进行比较）
* 2 3 1 4 (5)
* 2 1 3 4 (5)
* 2 1 3 4 (5)
* 
* 第三轮（继上一轮继续进行比较）
* 1 2 3 (4) (5)
* 
* 第四轮（继上一轮继续进行比较）
* 1 2 (3) (4) (5)
*/

#include "stdio.h"
#include "stdlib.h"

int main()
{
    int arr[5] = {3,2,5,1,4};

    for (int i = 0; i < 5; i++)
    {
        for (int j = i+1; j < 5; j++)
        {
            if(arr[j] < arr[i])
            {
                int nTemp = arr[i];
                arr[i] = arr[j];
                arr[j] = nTemp;
            }
        }
    }

    printf("[-] 排序后：");
    for (int k = 0; k < 5; k++) {
        printf("%d ",arr[k]);
    }
    printf("\n");
}
  ```


### 2、选择排序

1. 选择排序核心理念，就是`在当前数据中选择最小的数和首位进行交换`，交换完毕后，在下一轮排序中，已排序的第一位不进行考虑，每一轮排序如下所示：

```c
/*
* 选择排序：
* 
* 初始值：3 2 5 1 4
* 
* 第一轮
* 3 2 5 1 4	//在3 2 5 1 4中选择一个最小的数和第一位进行交换，最小的数为1，即1和3相互交换位置，如下所示
* 1 2 5 3 4	
* 
* 第二轮
* 2 5 3 4	//在2 5 3 4中选择一个最小的数与第一位进行交换，即最小数是2，第一位也是2，那么就不动
* 2 5 3 4
* 
* 第三轮
* 5 3 4		//在5 3 4中选择一个最小的数与第一位进行交换，即最小数是3，和5进行交换
* 3 5 4
* 
* 第四轮
* 5 4		//在5和4中选择一个中最小的数与第一位进行交换，即最小的数是3，和5进行交换
* 4 5
*/

#include "stdio.h"
#include "stdlib.h"

int main()
{
    int arr[5] = {3,2,5,1,4};

    for (int i = 0; i < 5; i++)
    {
        int nMinIndex = i;                  //默认当前0的位置是最小值
        for (int j = i+1; j < 5; j++)       //这里的for循环就是每个数整体比一遍，然后获得最小值，即整体数值里面，寻找最小值
        {
            if(arr[j] < arr[nMinIndex])     //注意下这里，后面的数和前面一个数比大小，如果后面的小，则获取下标值,给nMinIndex变量，然后后面的值再继续和当前获得最小值下标的值再进行比大小
            {
                nMinIndex = j;              //挨个比较，比较小的值的下标赋给nMinIndex
            }
        }
        if(nMinIndex != 0)
        {
            int nTemp = arr[i];
            arr[i] = arr[nMinIndex];
            arr[nMinIndex] = nTemp;
        }
    }

    printf("[-] 排序后：");
    for (int k = 0; k < 5; k++) {
        printf("%d ",arr[k]);
    }
    printf("\n");
}
```

1. 选择排序和冒泡排序谁的效率更高？
	- 选择排序效率更高。因为双方之间对比轮询的次数是一样的，但是交换的次数不一样。每一轮对比后，选择排序最多交换一次，但是冒泡排序最多交换(n-1)次；`交换才是最消耗资源的`



## 四、游戏案例演示

### 一、人物RPG游戏

​	具体代码请见第七天GameRPC项目



### 二、扑克牌游戏

#### 1、游戏要求

1. 要求显示各个扑克牌和花色
2. 实现能够随机洗牌
3. 实现能够给发牌
4. 实现每个玩家手中的牌按顺序显示
5. 能够实现查找牌的位置

具体代码请见第七天的Poke项目



## 四、作业

### 第一题



### 第二题

```c
//2. 用递归算法求10的阶乘。
 
#include <stdio.h>
#include <stdlib.h>
 
int factorial(int n)
{
	if (n == 1)
	{
		return 1;
	}
	else
	{
		return n * factorial(n - 1);
	}
}
 
int main()
{
	int res;
 
	res = factorial(10);
	printf("res = %d\n", res);
 
	return 0;
 
}
```





